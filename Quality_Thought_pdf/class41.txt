ex:
----
class  Test 
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println("try-block");
		}
		catch (Exception e)
		{
			System.out.println("catch-block");
		}
	}
}
o/p:
	try-block 

ex:
---
class  Test 
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println(10/0);
		}
		catch (ArithmeticException ae)
		{
			System.out.println("catch-block");
		}
	}
}
o/p:
	catch-block 

ex:
---
class  Test 
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println("stmt1");
			System.out.println(10/0);
			System.out.println("stmt2");
		}
		catch (ArithmeticException ae)
		{
			System.out.println("catch-block");
		}
	}
}


A try with multiple catch blocks 
==================================
A try block can have multiple catch blocks.

If a try block contains multiple catch blocks then order of catch block is very important. It should be from child to parent but not from parent to child.

ex:
---
class  Test 
{
	public static void main(String[] args) 
	{
		try
		{
			// System.out.println(10/0);
			
			int[] arr=null;
			System.out.println(arr[0]);
		}
		catch (ArithmeticException ae)
		{
			System.out.println("From AE");
		}
		catch(RuntimeException re)
		{
			System.out.println("From RE");
		}
		catch(Exception e)
		{
			System.out.println("From E");
		}
	}
}

Various methods to display exception details
============================================
Throwable class defines following three methods to display exception details.

1) printStackTrace()

2) getMessage()

3) toString()  

1) printStackTrace()
--------------------
It is used to display name of the exception, description of the exception and line number of the exception.

2) toString() 
-------------
It is used to display name of the exception and description of the exception.

3) getMessage()
---------------
It is used to display description of the exception.


ex:
---
class  Test 
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println(10/0);
		}
		catch (ArithmeticException ae)
		{
			ae.printStackTrace();
			
			System.out.println("=====================");
			
			System.out.println(ae.toString());
			
			System.out.println("=====================");
			
			System.out.println(ae.getMessage());
		}

	}
}

We can handle multiple exceptions using single catch block 

ex:
---
class  Test 
{
	public static void main(String[] args) 
	{
		try
		{
			//System.out.println(10/0);
			
			/*
			int[] arr=null;
			System.out.println(arr[0]);
			*/
			
			Thread.currentThread().setPriority(11);
		}
		catch (ArithmeticException | NullPointerException | IllegalArgumentException e)
		{
			e.printStackTrace();
		}

	}
}

finally block
==============
It is never recommanded to maintain cleanup code in try block because if any exception comes in try block then it won't be executed.

It is never recommanded to maintain cleanup code in catch block because is there is no exception in try block then catch block won't be executed.

We need a place where we can maintain cleanup code and it should execute irrespective of exception raised or not. Such block is called finally block.

syntax:
--------
	try
	{
		-
		- // Risky Code 
		-
	}
	catch(Exception e)
	{
		-
		- // Error Handling Code 
		-
	}
	finally
	{
		-
		- // Cleanup Code 
		-
	}
	
ex:
----
class  Test 
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println("try-block");	
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		finally
		{
			System.out.println("finally-block");	
		}

	}
}
o/p:
	try-block 
	finally-block 

ex:
---
class  Test 
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println(10/0);	
		}
		catch (ArithmeticException ae)
		{
			ae.printStackTrace();
		}
		finally
		{
			System.out.println("finally-block");	
		}

	}
}
o/p:
	java.lang.ArithmeticException: / by zero
        at Test.main(Test.java:7)
	finally-block

ex:
---
class  Test 
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println("stmt1");
			System.out.println(10/0);
			System.out.println("stmt2");
		}
		catch (ArithmeticException ae)
		{
			ae.printStackTrace();
		}
		finally
		{
			System.out.println("finally-block");	
		}

	}
}

o/p:
	stmt1
	java.lang.ArithmeticException: / by zero
        at Test.main(Test.java:8)
	finally-block


A try with finally combination is valid in java.

ex:
----
class  Test 
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println("try-block");
		}
		finally
		{
			System.out.println("finally-block");	
		}

	}
}

ex:
---
import java.util.Scanner;
class  Test 
{
	public static void main(String[] args) 
	{
		Scanner sc=null;
		try
		{
			sc = new Scanner(System.in);
			System.out.println("Enter the Name :");
			String name = sc.next();
			System.out.println("Welcome :"+name);
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		finally
		{
			sc.close();
		}
	}
}

Try-with-resources
===================
A try-with-resource introduced in Java 7.

A try-with-resource is a try statement that can hold one or more resources.

A try-with-resource ensures that each resource is closed at the end of the statement.

syntax:
------
	try()
	{
		- //code to be execute 
	}
	catch(Exception e)
	{
		- // code to be execute 
	}

ex:
---

import java.util.Scanner;
class  Test 
{
	public static void main(String[] args) 
	{
		try(Scanner sc = new Scanner(System.in);)
		{
			System.out.println("Enter the Name :");
			String name = sc.nextLine();
			System.out.println("Welcome :"+name);
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
	}
}


Q) What is the difference between final, finally and finalize method?

final 
------
It is a modifier which is applicable for variables, methods and classes.
If we declare any variable as final then reassignment of that variable is not possible.
If we declare any method as final then overriding of that method is not possible.
If we declare any class as final then creating child class is not possible. 

finally 
---------
It is a block which contains cleanup code and it should execute irrespective of exception raised or not.

finalize 
---------
It is a method called by garbage collector just before destroying an object for cleanup activity.



Garbage Collector 
=================
Garbage collector is also known as Deamon Thread.

A thread which is running in a background is called deamon thread.

It is a programming features which manages memory allocation and deallocation for our program.

There are two ways to call garbage collector in java.

1) System.gc() 

2) Runtime.getRuntime().gc() 

ex:
----
class  Test 
{
	//instance variable 
	int i=10;
	
	public static void main(String[] args) 
	{
		Test t = new Test();
		System.out.println(t.i); // 10
		
		t=null;
		
		System.gc();
	}
	public void finalize()
	{
		System.out.println("finalized method");
	}
}

ex:
---
class  Test 
{
	//instance variable 
	int i=10;
	
	public static void main(String[] args) 
	{
		Test t = new Test();
		System.out.println(t.i); // 10
		
		t=null;
		
		Runtime.getRuntime().gc();
	}
	public void finalize()
	{
		System.out.println("finalized method");
	}
}

throw statement 
================
Sometimes we will create exception object explicitly and handover to JVM manually by using throw statement.

ex:
	throw new ArithmeticException("Don't divide by zeroo");

Diagram: class41.1


throws statement 
================
If any checked exception raised in our program we must and should handle that exception by using try and catch block or by using throws statement.

ex:
---
class  Test 
{
	public static void main(String[] args) 
	{
		try
		{
			Thread.sleep(3000);
			System.out.println("Welcome to Java");		
		}
		catch (InterruptedException ie)
		{
			ie.printStackTrace();
		}
	}
}

ex:
---
class  Test 
{
	public static void main(String[] args)throws InterruptedException  
	{
			Thread.sleep(5000);
			System.out.println("Welcome to Java");		
	}
}

2) Userdefined exceptions
=========================
Exceptions which are created by the user based on the application requirements are called custom exceptions.
ex:
	NoInterestInJavaException 
	NoPracticeNoJobException 
	InSufficientFundException 
	TooYoungException 
	TooOldException 
	and etc.

ex:
---
import java.util.Scanner;
class TooYoungException extends RuntimeException 
{
	TooYoungException(String msg)
	{
		super(msg);
	}
}
class TooOldException extends RuntimeException 
{
	TooOldException(String msg)
	{
		super(msg);
	}
}
class  Test 
{
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the age :");
		int age = sc.nextInt();
		
		if(age<18)
			throw new TooYoungException("U r not eligible to vote");
		else
			throw new TooOldException("U r eligible to vote");
	}
}









	


























































































































































