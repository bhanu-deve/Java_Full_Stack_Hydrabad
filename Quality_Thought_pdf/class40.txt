Q) Write a java program to multiply two arrays?

input:
	5 7 2 
	3 1
output:
	17732 (572*31)

ex:
---
class Test  
{
	public static void main(String[] args) 
	{
		int[] arr1 = {5,7,2};
		int[] arr2 = {3,1};
		
		int a = Integer.parseInt(arrayToString(arr1));
		int b = Integer.parseInt(arrayToString(arr2));
		System.out.println(a*b);
	}
	public static String arrayToString(int[] arr)
	{
		StringBuffer sb = new StringBuffer();
		for(int i : arr)
		{
			sb.append(i);
		}
		
		return sb.toString();
	}
}


Q) Write a java program to display string in a given format?

input:
	ABBCCCDDDD
output:
	A1B2C3D4

ex:
----
class Test  
{
	public static void main(String[] args) 
	{
		String str="ABBCCCDDDD";
		
		StringBuffer sb = new StringBuffer();
		
		int cnt = 1;
		for(int i=0;i<str.length();i++)
		{
			if(i<str.length()-1 && str.charAt(i) == str.charAt(i+1))
			{
				cnt++;	
			}
			else
			{
				sb.append(str.charAt(i)).append(cnt);
				cnt=1;
			}
		}
		System.out.println(sb.toString());
	}
}


Q) Write a java program to display number of 2's

input:
	22

output:
	6 (2,12,20,21,22)

ex:
---

class Test  
{
	public static void main(String[] args) 
	{
		int num = 22;
		
		StringBuffer sb = new StringBuffer();
		
		for(int i=1;i<=num;i++)
		{
			sb.append(i); 	
		}
		
		int cnt = 0;
		for(int i=0;i<sb.length();i++)
		{
			int n  = Character.getNumericValue(sb.charAt(i));
			if(n==2)
			{
				cnt++;
			}
		}
		System.out.println(cnt);
	}
}

StringBuilder
=============
StringBuilder is exactly same as StringBuffer with following differences.

StringBuffer					StringBuilder 
------------					--------------
Methods are synchronized.			Methods are not synchronized.

At a time only one thread is allowed to 	Multiple threads are allowed to operate 	
operate on StringBuffer object.Hence 		on StringBuilder object. Hence StringBuilder
StringBuffer is thread safe.			is not thread safe.

Waiting time of a thread will increase		There is not waiting threads  effectively 
effectively performance is low.			performance is high.

It is introduced in 1.0 version.		It is introduced in 1.5 version.


Note:
----
If our content not change frequently then it is recommanded to use String.

If our content change frequently where thread safety is required then we need to use StringBuffer.

If our content change freqently where thread safety is not required then we need to use StringBuilder.


Q) Write a java program to display reverse of a given number?

input:
	123

output:
	321
ex:
--
class Test  
{
	public static void main(String[] args) 
	{
		int n = 123;
		
		String s = Integer.toString(n);
		
		StringBuilder sb = new StringBuilder(s);
		
		s = sb.reverse().toString();
		
		n = Integer.parseInt(s);
		
		System.out.println(n);
	}
}

StringTokenizer 
===============
StringTokenizer is a class which is present in java.util package.

StingTokenizer class is used to tokenize the string irrespective of regular expression.

We can create StringTokenizer object as follow.

ex:
	StringTokenizer st = new StringTokenizer(String str, RegularExpression regex);

StringTokenizer class contains following five methods.
ex:
	public int countTokens()
	public boolean hasMoreTokens()
	public String nextToken()
	public boolean hasMoreElements()
	public Object nextElement() 

ex:
----
import java.util.StringTokenizer;
class Test  
{
	public static void main(String[] args) 
	{
		StringTokenizer st = new StringTokenizer("This is java class");
		System.out.println(st.countTokens());
	}
}
Note:
----
	Here space is a default regular expression.

ex:
---
import java.util.StringTokenizer;
class Test  
{
	public static void main(String[] args) 
	{
		StringTokenizer st = new StringTokenizer("This is java class"," ");
		while(st.hasMoreTokens())
		{
			String s = st.nextToken();
			System.out.println(s); 
		}
	}
}

ex:
----
import java.util.StringTokenizer;
class Test  
{
	public static void main(String[] args) 
	{
		StringTokenizer st = new StringTokenizer("This is java class"," ");
		while(st.hasMoreElements())
		{
			String s = (String)st.nextElement();
			System.out.println(s); 
		}
	}
}

ex:
---
import java.util.StringTokenizer;
class Test  
{
	public static void main(String[] args) 
	{
		StringTokenizer st = new StringTokenizer("9,99,999",",");
		while(st.hasMoreElements())
		{
			String s = (String)st.nextElement();
			System.out.println(s); 
		}
	}
}

Random 
=========
Random class present in java.util package.

It is used to generate psuedo random numbers.

ex:
---
import java.util.Random;
class Test  
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		
		int n = r.nextInt();
		
		System.out.println(n); 
	}
}

ex:
---
import java.util.Random;
class Test  
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		
		int n = r.nextInt(100);
		
		System.out.println(n); 
	}
}

ex:
---
import java.util.Random;
class Test  
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		
		int n = r.nextInt(15,50);
		
		System.out.println(n); 
	}
}


Exception Handling 
==================

Q) What is the difference between Exception and Error?

Exception 
----------
	Exception is a problem for which we can provide solution programmatically.
	Exception will occur due to syntax errors.
	ex:
		FileNotFoundException 
		ArithmeticException 
		IllegalArgumentException 

Error
------
	Error is a problem for which we can't provide solution programmatically.
	Error will occur due to lack of system resources.
	ex:
		OutOfMemoryError 
		StackOverFlowError
		LinkageError 
		
As a part of java application development is a responsibility of a programmer to provide smooth termination for every java program.

We have two types of terminations.

1) Smooth termination / Graceful termination 
-------------------------
During the program execution suppose if we are not getting any interruption in the middle of the program such type of termination is called smooth termination.

ex:
---
class Test  
{
	public static void main(String[] args) 
	{
		System.out.println("Hello World");
	}
}


2) Abnormal termination 
-----------------
During the program execution suppose if we are getting any interruption in the middle of the program such type of termination is called abnormal termination.

ex:
---

class Test  
{
	public static void main(String[] args) 
	{
		System.out.println(10/0);
	}
}

If any exception raised in our program we must and should handle that exception otherwise our program will terminates abonormally.

Here exception will display name of the exception, description of the exception and line number of the exception.


Exception 
=========
It is a unwanted, unexpected event which disturbs normal flow of our program.

Exceptions always raised at runtime so they are also known as runtime events.

The main objective of exception handling is to provide graceful termination.

In java, exceptions are divided into two types.

1) Predefined exceptions 

2) Userdefiend exceptions 

1) Predefined exceptions
---------------------------
Built-in exceptions are called predefined exceptions.

It is classified into two types.

Diagram: class40.1

i) Checked Exceptions 
-----------------------
Exceptions which are checked by the compiler at the time of compilation is called checked exceptions.
ex:
	InterruptedException 
	EOFException 
	IOException 


ii) Unchecked Exceptions 
--------------------------
Exceptions which are checked by the JVM at the time of runtime is called unchecked exceptions.
ex:
	ClassCastException 
	NullPointerException 
	ArithmeticException 

If any checked exception raised in our program we must and should handle that exception by using try and catch block.


try block 
=========
It is a block which contains risky code.

It is associate with catch block.

It is used to throw the exception to catch block.

If any exception raised in try block then it won't be executed.

catch block 
============
It is a block which contains error handling code.

It always associate with try block.

It is used to catch the exception which is thrown by try block.

If there is no exception in try block then catch block won't be executed.

A catch block will take exception name as a parameter and that name must match with exception class name.


syntax:
------
	try 
	{
		-
		- // Risky Code 	
		-
	}
	catch(Exception e)
	{
		-
		- // Error Handling Code 
		-
	}






























































































































