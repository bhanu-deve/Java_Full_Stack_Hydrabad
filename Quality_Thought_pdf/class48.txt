2) By implementing Runnable interface
=====================================
class MyRunnable implements Runnable 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class Test  
{
	public static void main(String[] args) 
	{
		MyRunnable r = new MyRunnable();
		Thread t = new Thread(r); // r is a targatable interface 
		t.start();
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}


Daemon Thread 
==============
Daemon thread is a low priority thread that runs in a background.

There are many deamon threads are running internally.
ex:
	Garbage Collector 
	Finalizer 
	Signal Dispatch
	Action Listener 
	and etc.

Deamon thread provides services to user threads.

Life of daemon thread is depend upon user threads. If user threads died then daemon thread will die automatically.

We can change the behaviour of daemon thread before user threads. If we change behaviour of deamon thread after user threads then we will get one runtime exception called IllegalThreadStateException.

To change the behaviour deamon thread we will use setDeamon(true) method.

To check current thread is a deamon or not we need to use isDeamon() method.


ex:
---
class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(Thread.currentThread().isDaemon());
			System.out.println("Child-thread");
		}
	}
}
class Test 
{
	public static void main(String[] args)
	{
		MyThread t = new MyThread();
		t.setDaemon(true);
		t.start();
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-thread");
		}	
	}
}

Setting and Getting name of a thread 
====================================
In java every thread has a name automatically provided by the JVM or explicitly provided by the programmer.

We have following methods to set and get name of a thread.
ex:
	public final void setName(String name)
	public final String getName() 

ex:
----
class MyThread extends Thread 
{
	
}
class Test 
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getName()); // main 
		
		MyThread t = new MyThread();
		System.out.println(t.getName()); // Thread-0
		
		Thread.currentThread().setName("Parent-Thread");	
		System.out.println(Thread.currentThread().getName()); // Parent-Thread 
		
		t.setName("Child-Thread");
		System.out.println(t.getName()); // Child-Thread			
	}
}


Thread Priority 
================
In java, every thread has a priority automatically generated by the JVM or explicitly provided by the programmer. 

The valid range of thread priority is 1 to 10. where 1 is a least priority and 10 is a highest priority. 

If we take more then 10 prioriy then we will get IllegalArgumentException.

A Thread class defines following constants as thread priority.
ex:
	Thread.MAX_PRIORITY  = 10
	Thread.NORM_PRIORITY = 5
	Thread.MIN_PIRORITY  = 1 

We don't have such constants like LOW_PRIORITY and HIGH_PRIORITY.

A thread schedular uses thread priority while allocating to CPU.

A thread which is having highest priority that will be executed first.

If multiple threads having same priority then we can't expect any execution order.

We have following methods to set and get thread priority.
ex:
	public final void setPriority(int priority)
	public final int getPriority() 

ex:
---
class MyThread extends Thread 
{
	
}
class Test 
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getPriority()); // 5
		
		MyThread t = new MyThread();
		System.out.println(t.getPriority()); // 5
		
		Thread.currentThread().setPriority(9);	
		System.out.println(Thread.currentThread().getPriority()); // 9 
		
		t.setPriority(4);
		System.out.println(t.getPriority()); // 4
		
		t.setPriority(11); // R.E IllegalArgumentException 
	}
}

Various ways to prevent a thread from execution 
===============================================
There are three ways to prevent(stop) a thread from execution.

1) yield() 

2) join() 

3) sleep() 


1) yield() 
-----------
It pause current execution thread a gives the chance to other threads having same priority.

If there is low priority threads or not waiting threads then same thread will continue it's execution.

If multiple waiting threads having same priority then we can't expect any execution order.

A thread which is yielded when it will get a chance for execution is dependent upon mercy of thread schedular.
ex:
	public static native void yield() 

Diagram: class48.1

ex:
---
class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class Test 
{
	public static void main(String[] args)
	{
		MyThread t = new MyThread();
		t.start();
		
		for(int i=1;i<=5;i++)
		{
			Thread.currentThread().yield();
			System.out.println("Parent-Thread");
		}
	}
}

2) join() 
=========
If a thread wants to wait untill the completion of some other threads then we need to use 
join() method.

A join() method throws one checked exception i.e InterruptedException so we must and should handle that exception by using try and catch block or by using throws statement.

ex:
	public final void join()throws InterruptedException
	public final void join(long ms)throws InterruptedException
	public final void join(long ms,int ns)throws InterruptedException

Diagram: class48.2

ex:
---
class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class Test 
{
	public static void main(String[] args)throws InterruptedException
	{
		MyThread t = new MyThread();
		t.start();
		t.join();
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}













	



3) sleep()
==========
If a thread don't want to perform any operations on perticular amount of time then we need to use sleep() method.

A sleep() method throws one exception called InterruptedException so we must and should handle that exception by using try and catch block or by using throws statement.

ex:
	public static native void sleep()throws InterruptedException 
	public static native void sleep(long ms)throws InterruptedException 
	public static native void sleep(long ms,int ns)throws InterruptedException 	

Diagram: class48.3

ex:
---
class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}
class Test 
{
	public static void main(String[] args)
	{
		MyThread t = new MyThread();
		t.start();
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}


Problem without synchronization 
===============================
If there is no synchronization then we will face following problems.

1) Data inconsistency 

2) Thread interference 


ex:
---
class Table 
{
	void printTable(int n)
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}
class MyThread1 extends Thread 
{
	Table t;
	
	MyThread1(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
}

class MyThread2 extends Thread 
{
	Table t;
	
	MyThread2(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(10);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Table obj = new Table();
		MyThread1 t1=new MyThread1(obj);
		MyThread2 t2=new MyThread2(obj);
		
		t1.start();
		t2.start();
	}
}



Synchronization 
===============
A synchronized keyword is applicable for methods and blocks.

It allows only one thread at a time on given object. Hence we can achieve thread safety.

The main advantage of synchronization is it gives data consistency.

The main disadvantage of synchronization is waiting time of a thread will increase effectively perform will reduce.

It internally uses lock mechanism.

If any thread wants access object lock first it has to acquire lock of it and it will release the lock when thread completes it's task.

If there is a specific requirement then only go with synchronization.

In synchronization threads will get the lock automatically. 

If a thread is executing synchronized method then other threads are not allowed to execute other synchronized methods. But they can execute non-synchronized method concurently.

ex:
---
class Table
{
	synchronized void printTable(int n)
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)  
			{
				ie.printStackTrace();
			}
		}
	}
}
class MyThread1 extends Thread 
{
	Table t;
	MyThread1(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
}
class MyThread2 extends Thread 
{
	Table t;
	MyThread2(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(10);
	}	
}
class Test 
{
	public static void main(String[] args)
	{
		Table obj = new Table();
		MyThread1 t1=new MyThread1(obj);
		MyThread2 t2=new MyThread2(obj);
		t1.start();
		t2.start();
	}
}

synchronized block 
====================
If we want to perform synchronization on specific resource of a program then we need to use synchronized block.

Assume we have 100 lines of code but we need to perform synchronization only for 5 lines then we need to use synchronized block.

If we keep all the logic inside synchronized block then it acts like a synchronized method.

ex:
---
class Table
{
	void printTable(int n)
	{
		synchronized(this)
		{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)  
			{
				ie.printStackTrace();
			}
		}
		}//syn 
	}
}
class MyThread1 extends Thread 
{
	Table t;
	MyThread1(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
}
class MyThread2 extends Thread 
{
	Table t;
	MyThread2(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(10);
	}	
}
class Test 
{
	public static void main(String[] args)
	{
		Table obj = new Table();
		MyThread1 t1=new MyThread1(obj);
		MyThread2 t2=new MyThread2(obj);
		t1.start();
		t2.start();
	}
}

static synchronization 
======================
If we declare any static method as synchronized then it is called static synchronization.

In static synchronization the lock will be on class not on object.

ex:
--
class Table
{
	static synchronized void printTable(int n)
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)  
			{
				ie.printStackTrace();
			}
		}
	}
}
class MyThread1 extends Thread 
{
	public void run()
	{
		Table.printTable(5);
	}
}
class MyThread2 extends Thread 
{
	public void run()
	{
		Table.printTable(10);
	}	
}
class Test 
{
	public static void main(String[] args)
	{
		MyThread1 t1=new MyThread1();
		MyThread2 t2=new MyThread2();
		t1.start();
		t2.start();
	}
}


Inter-Thread Communication 
==========================
Inter-Thread communication is possible by using wait(), notify() and notifyAll() method.

A wait(), notify() and notifyAll() methods of Object class not Thread class.

A thread which is waiting for notification has to call wait() method.

A thread which is giving the notification has to call notify() or notifyAll() method.

To call wait(), notify() or notifyAll() method we required synchronized area otherwise we will get IllegalMonitorStateException.

If we call wait() method our thread will release the lock immediately and goes to waiting state.

If we call notify() or notifyAll() method then our thread will release the lock but not immediately.

Except wait() , notify(), notifyAll() method there is no way to relase the lock.

ex:
--
class MyThread extends Thread 
{
	int total=0;
	
	public void run()
	{
		synchronized(this)
		{
			System.out.println("Child started calculation");
			
			for(int i=1;i<=10;i++)
			{
				total+=i;
			}
			
			System.out.println("Child giving notification");
			this.notify();
		}
	}
}
class Test 
{
	public static void main(String[] args)throws InterruptedException
	{
		MyThread t = new MyThread();
		t.start();
		
		synchronized(t)
		{
			System.out.println("Main Method waiting for notification ");
			t.wait();
			System.out.println("Main method got notification");
			System.out.println(t.total);
		}
	}
}

DeadLock in Java
=================
Deadlock will occur in a situation where one thread wants to acquire lock of another thread and that thread wants to acquire lock which is acquired by first thread. Here both the threads are ready to release the lock but no body will release such situation is called deadlock.

ex:
---

class Test 
{
	public static void main(String[] args)
	{
		final String res1="Hi";
		final String res2="Bye";
		
		//Anonymous inner class 
		Thread t1=new Thread()
		{
			public void run()
			{
				synchronized(res1)
				{
					System.out.println("Thread1: Locking Resource1");
					
					synchronized(res2)
					{
						System.out.println("Thread1: Locking Resource2");
					}
				}
			}
		};
		
		//Anonymous inner class 
		Thread t2=new Thread()
		{
			public void run()
			{
				synchronized(res2)
				{
					System.out.println("Thread2: Locking Resource2");
					
					synchronized(res1)
					{
						System.out.println("Thread2: Locking Resource1");
					}
				}
			}
		};
		t1.start();
		t2.start();
	}
}

Drawbacks of multithreading
==========================
1) Thread starvation 

2) DeadLock 

3) Debugging 
















































