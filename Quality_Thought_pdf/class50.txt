ex:
---
import java.util.*;
import java.util.stream.*;
class  Test 
{
	public static void main(String[] args) 
	{
		List<Integer> list = List.of(7,1,3,9,2);
		
		List<Integer> newList = list.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());
	
		System.out.println(newList);
	}
}

ex:
---
import java.util.*;
import java.util.stream.*;
class  Test 
{
	public static void main(String[] args) 
	{
		List<Integer> list = List.of(7,1,3,9,2,4);
		
		long count = list.stream().filter(i->i%2==0).count();
	
		System.out.println(count);
	}
}

ex:
----
import java.util.*;
import java.util.stream.*;
class  Test 
{
	public static void main(String[] args) 
	{
		List<Integer> list = List.of(7,1,3,9,1,7,3,2,4);
		
		List<Integer> newList = list.stream().distinct().collect(Collectors.toList());
	
		System.out.println(newList);
	}
}

ex:
---
import java.util.*;
import java.util.stream.*;
class  Test 
{
	public static void main(String[] args) 
	{
		List<Integer> list = List.of(6,2,9,4,7);
		
		long min = list.stream().min((i1,i2)-> i1.compareTo(i2)).get();
	
		System.out.println(min);
	}
}

ex:
---
import java.util.*;
import java.util.stream.*;
class  Test 
{
	public static void main(String[] args) 
	{
		List<Integer> list = List.of(6,2,9,4,7);
		
		long max = list.stream().max((i1,i2)-> i1.compareTo(i2)).get();
	
		System.out.println(max);
	}
}

forEach() method 
================
A forEach() method introduced in Java 8.

It is used to iterate the objects from Collections.

ex:
---
import java.util.*;
class  Test 
{
	public static void main(String[] args) 
	{
		List<Integer> list = List.of(6,9,1,2,5);
		
		list.forEach(element-> System.out.print(element+" "));
	}
}

ex:
----
import java.util.*;
class  Test 
{
	public static void main(String[] args) 
	{
		Set<Integer> set = Set.of(5,8,1,2,9);
		
		set.forEach(element-> System.out.print(element+" "));
	}
}

ex:
---
import java.util.*;
class  Test 
{
	public static void main(String[] args) 
	{
		Map<Integer,String> map = Map.of(1,"one",2,"two",3,"three");
		
		map.forEach((key,value)->System.out.println(key+"="+value));
	}
}

Method Reference (::)
=====================
Method reference introduced in Java 8.

It is a special type of lamda expression.

It is a concise way to call the methods or constructors instead of entire method call.

ex:
---
import java.util.*;
class  Test 
{
	public static void main(String[] args) 
	{
		List<Integer> list = List.of(7,1,9,2,4);
		
		list.forEach(System.out::println);
	}
}

ex:
---
import java.util.*;
class  Test 
{
	public static void main(String[] args) 
	{
		Map<Integer,String> map = Map.of(1,"one",2,"two",3,"three");
		
		map.forEach(Test::entry);
	}
	public static void entry(int key,String value)
	{
		System.out.println(key+"="+value);
	}
}


Interview Question 
==================

Q) Write a java program to display employees information in sorting order of employee id?

import java.util.*;
import java.util.stream.*;
class Employee 
{
	private int empId;
	private String empName;
	private double empSal;
	
	public Employee(int empId,String empName,double empSal)
	{
		this.empId=empId;
		this.empName=empName;
		this.empSal=empSal;
	}
	
	public int getEmpId()
	{
		return empId;
	}
	public String getEmpName()
	{
		return empName;
	}
	public double getEmpSal()
	{
		return empSal;
	}
	
	public String toString()
	{
		return empId+" "+empName+" "+empSal;
	}
}
class Test 
{
	public static void main(String[] args)
	{
		List<Employee> list = new ArrayList<Employee>();
		list.add(new Employee(204,"Kelvin",4000d));
		list.add(new Employee(201,"Nelson",1000d));
		list.add(new Employee(203,"Alan",3000d));
		list.add(new Employee(202,"Mark",2000d));
		
		List<Employee> newList = list.stream().sorted(Comparator.comparingInt(Employee::getEmpId)).collect(Collectors.toList());
		
		newList.forEach(employee->System.out.println(employee));
	}
}


Q) Write a java program to display employees information in sorting of employee name?

import java.util.*;
import java.util.stream.*;
class Employee 
{
	private int empId;
	private String empName;
	private double empSal;
	
	public Employee(int empId,String empName,double empSal)
	{
		this.empId=empId;
		this.empName=empName;
		this.empSal=empSal;
	}
	
	public int getEmpId()
	{
		return empId;
	}
	public String getEmpName()
	{
		return empName;
	}
	public double getEmpSal()
	{
		return empSal;
	}
	
	public String toString()
	{
		return empId+" "+empName+" "+empSal;
	}
}
class Test 
{
	public static void main(String[] args)
	{
		List<Employee> list = new ArrayList<Employee>();
		list.add(new Employee(204,"Kelvin",4000d));
		list.add(new Employee(201,"Nelson",1000d));
		list.add(new Employee(203,"Alan",3000d));
		list.add(new Employee(202,"Mark",2000d));
		
		List<Employee> newList = list.stream().sorted(Comparator.comparing(Employee::getEmpName)).collect(Collectors.toList());
		
		newList.forEach(employee->System.out.println(employee));
	}
}


Thread Pool 
============
A thread pool in java is a managed set of pre-initialized worker threads that are used to handle multiple tasks concurently.

Instead of creating new thread for each task. We can submit the task to thread pool, which reuses fixed number of threads to handle multiple tasks efficiently.

Diagram: class50.1

Advantages:

> Improved Performance 
 - It handles overhead of creating new thread for each task.

> Resource Management
 - It handles concurent threads to prevent the load on system.

> Scalibility:
 - It handles thousands of short-lived tasks simultenously.	

> Managable
 - Task can be queued, scheduled and cancelled.


java.util.concurrent 
====================
Diagram: class50.2


ThreadPoolExecutor 
===================
ThreadPoolExecutor class is used to create custamizable thread pool.

Diagram: class50.3


import java.util.concurrent.*;
class Test 
{
	public static void main(String[] args)
	{
		ThreadPoolExecutor executor = new ThreadPoolExecutor(3,5,10,TimeUnit.MINUTES
											,new ArrayBlockingQueue<>(5)
											, Executors.defaultThreadFactory()
											, new ThreadPoolExecutor.DiscardPolicy()
											);
		
		for(int i=1;i<=11;i++)
		{
			executor.submit(()->{
				try
				{
					Thread.sleep(5000);
				}
				catch (Exception e)
				{
					e.printStackTrace();
				}
				System.out.println("Task processing by :"+Thread.currentThread().getName());
			});
		}
		
		executor.shutdown();
	}
}









































































