Interface
==========
Interface is a blue print of a class and it is a collection of zero or more abstract methods.

Abstract methods are incomplete methods because they ends with semicolon and do not have any body.
ex:
	public abstract void m1();

It is not possible to create object for interfaces.

To write implementation for abstract methods of an interface we will use implementation class.

It is possible to create object for implementation because it contains method with body.

By default every abstract method is a public and abstract.
ex:
	void m1()

Interface contains only constants i.e public static final.

If we know service requirement specification then we need to use interface.

Diagram: class33.1

ex:
-----
interface A 
{
	public abstract void m1();
}
class B implements  A
{
	@Override
	public void m1()
	{
		System.out.println("M1-Method");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		A a = new B();
		a.m1();
	}
}

ex:
---
interface A 
{
	public abstract void m1();
}
class Test 
{
	public static void main(String[] args)
	{
		A a = new A()
		{
			public void m1()
			{
				System.out.println("From M1-Method");
			}
		};
		a.m1();
	}
}

If interface contains four methods then we need to override all methods otherwise we will get compile time error.

interface A 
{
	public abstract void show();
	public void display();
	abstract void view();
	void see();
}
class B implements A 
{

	@Override 
	public void show()
	{
		System.out.println("show-method");
	}
	@Override 
	public void display()
	{
		System.out.println("display-method");
	}
	@Override 
	public void view()
	{
		System.out.println("view-method");
	}
	@Override 
	public void see()
	{
		System.out.println("see-method");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		A a = new B();
		a.show();
		a.display();
		a.view();
		a.see();
	}
}

Interface can extends more then one interface simultenously.

ex:
---
interface A 
{
	void m1();
}
interface B 
{
	void m2();
}
interface C extends A,B
{
	void m3();
}
class D implements C 
{
	@Override 
	public void m1()
	{
		System.out.println("M1-Method");
	}

	@Override 
	public void m2()
	{
		System.out.println("M2-Method");
	}

	@Override 
	public void m3()
	{
		System.out.println("M3-Method");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		C c = new D();
		c.m1();
		c.m2();
		c.m3();
	}
}

A class can implements more then one interface.

ex:
---
interface Father 
{
	float HT=6.2f;
	void height();
}
interface Mother 
{
	float HT=5.8f;
	void height();
}
class Child implements Father,Mother 
{
	@Override 
	public void height()
	{
		float height = (Father.HT+Mother.HT)/2;
		System.out.println("Child height :"+height);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Father f = new Child();
		f.height();
		
		//or 
			
		Mother m = new Child();
		m.height();
	}
}

Note:
-----
According to Java 8 , Interface is a blue print of a class and it is a collection of abstract methods, default methods and static methods.


Marker interface 
================
Interface which does not has any methods or constants is called marker interface.

In general, empty interface is called marker interface.

We have following list of marker interfaces.
ex:
	Serializable 
	Cloneable 
	Remote 
	and etc.

Using marker interface we will get some ability to do.


Abstract class 
==============
Abstract class is a collection of zero or more abstract methods and concrete methods.

A abstract keyword is applicable for methods and classes not for variables.

It is not possible to create object for abstract classes.

To write the implementation of abstract methods an abstract class we will use sub classes.

By default every abstract method is a public and abstract.

Abstract class contains only instance variables.

If we know partial implementation then we need to use abstract class.

ex:
---
abstract class A 
{
	//abstract method 
	public abstract void m1();
	
	//concrete method 
	public void m2()
	{
		System.out.println("concrete-method");
	}
}
class B extends A 
{
	@Override
	public void m1()
	{
		System.out.println("abstract-method");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		B b = new B();
		b.m1();
		b.m2();
	}
}




















































