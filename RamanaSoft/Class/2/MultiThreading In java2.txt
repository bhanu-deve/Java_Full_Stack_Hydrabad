Creating a thread
=================

There are two ways to create a thread:

1)By extending Thread class
2)By implementing Runnable interface.

Commonly used methods of Thread class:
--------------------------------------

1)public void run(): is used to perform action for a thread.

2)public void start(): starts the execution of the thread.JVM calls the run() method on the thread.

3)public void sleep(long miliseconds): Causes the currently executing thread to sleep (temporarily cease execution) 
                                       for the specified number of milliseconds.

4)public void join(): waits for a thread to die.

5)public void join(long miliseconds): waits for a thread to die for the specified miliseconds.

6)public int getPriority(): returns the priority of the thread.

7)public int setPriority(int priority): changes the priority of the thread.

8)public String getName(): returns the name of the thread.

9)public void setName(String name): changes the name of the thread.

10)public Thread currentThread(): returns the reference of currently executing thread.

11)public int getId(): returns the id of the thread.

12)public Thread.State getState(): returns the state of the thread.

13)public boolean isAlive(): tests if the thread is alive.

14)public void yield(): causes the currently executing thread object to temporarily pause and allow other threads to     execute.

15)public void suspend(): is used to suspend the thread(depricated).

16)public void resume(): is used to resume the suspended thread(depricated).

17)public void stop(): is used to stop the thread(depricated).

18)public boolean isDaemon(): tests if the thread is a daemon thread.

19)public void setDaemon(boolean b): marks the thread as daemon or user thread.

20)public void interrupt(): interrupts the thread.

21)public boolean isInterrupted(): tests if the thread has been interrupted.

22)public static boolean interrupted(): tests if the current thread has been interrupted.

Runnable interface:
-------------------
The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. Runnable interface have only one method named run().

public void run(): is used to perform action for a thread.

Starting a thread:
------------------
The start() method of Thread class is used to start a newly created thread. It performs the following tasks:

1)A new thread starts(with new callstack).

2)The thread moves from New state to the Runnable state.

3)When the thread gets a chance to execute, its target run() method will run.

Example extending thread class
------------------------------

package Threads;

class Multi extends Thread{
	
	public void run() {
		
		try {
			System.out.println("Thread"+Thread.currentThread().getId()+"is running");
		}catch(Exception e) {
			System.out.println(e);
		}
	}
}

public class MultiThreadTest {

	public static void main(String[] args) {
		
		int n= 5;
		for(int i= 0;i<n;i++) {
		
		Multi m = new Multi();
		m.start();
		}

	}

}

Java Thread Example by implementing Runnable interface
-------------------------------------------------------

package Threads;

class Multi implements Runnable{
	
	public void run() {
		
		try {
			System.out.println("Thread"+Thread.currentThread().getId()+"is running");
		}catch(Exception e) {
			System.out.println(e);
		}
	}
}

public class MultiThreadTest {

	public static void main(String[] args) {
		
		int n= 5;
		for(int i= 0;i<n;i++) {
		
		Multi m = new Multi();
		Thread t = new Thread(m);
		t.start();
		}

	}

}

Thread Scheduler in Java
------------------------

A component of Java that decides which thread to run or execute and which thread to wait is called a thread scheduler in Java. In Java, a thread is only chosen by a thread scheduler if it is in the runnable state. However, if there is more than one thread in the runnable state, it is up to the thread scheduler to pick one of the threads and ignore the other ones. There are some criteria that decide which thread will execute first. There are two factors for scheduling a thread i.e. Priority and Time of arrival.

Priority:
---------- 
Priority of each thread lies between 1 to 10. If a thread has a higher priority, it means that thread has got a better chance of getting picked up by the thread scheduler.

Time of Arrival:
----------------
Suppose two threads of the same priority enter the runnable state, then priority cannot be the factor to pick a thread from these two threads. In such a case, arrival time of thread is considered by the thread scheduler. A thread that arrived first gets the preference over the other threads.

Thread.sleep()
=============

syntax of sleep() method:

public static void sleep(long mls) throws InterruptedException   
public static void sleep(long mls, int n) throws InterruptedException   

The following are the parameters used in the sleep() method.

mls: The time in milliseconds is represented by the parameter mls. The duration for which the thread will sleep is given by the method sleep().

n: It shows the additional time up to which the programmer or developer wants the thread to be in the sleeping state. The range of n is from 0 to 999999.

Example of sleep() method
-------------------------

package Test;

public class TestSleep extends Thread {

	public void run() {

		for (int i = 0; i < 5; i++) {

			try {
				Thread.sleep(5000);
			} catch (InterruptedException e) {
				System.out.println(e);
			}
			System.out.println(i);
		}
	}

	public static void main(String[] args) {

		TestSleep t = new TestSleep();
		TestSleep t1 = new TestSleep();

		t.start();
		t1.start();

	}

}



