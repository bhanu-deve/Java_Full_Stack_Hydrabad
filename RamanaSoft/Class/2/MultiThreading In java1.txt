Multithreading In java
======================

Multithreading in Java is a process of executing multiple threads simultaneously.

A thread is a lightweight sub-process, the smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking.

However, we use multithreading than multiprocessing because threads use a shared memory area. They don't allocate separate memory area so saves memory, and context-switching between the threads takes less time than process.

Java Multithreading is mostly used in games, animation, etc.

Advantages of Java Multithreading
---------------------------------
1) It doesn't block the user because threads are independent and you can perform multiple operations at the same time.

2) You can perform many operations together, so it saves time.

3) Threads are independent, so it doesn't affect other threads if an exception occurs in a single thread.

Multitasking is a process of executing multiple tasks simultaneously. 
We use multitasking to utilize the CPU. Multitasking can be achieved in two ways:

.Process-based Multitasking (Multiprocessing)
.Thread-based Multitasking (Multithreading)

Process-based Multitasking (Multiprocessing)
--------------------------------------------

1)Each process has an address in memory. In other words, each process allocates a separate memory area.

2)A process is heavyweight.

3)Cost of communication between the process is high.

4)Switching from one process to another requires some time for saving and loading registers, memory maps, updating lists.

Thread-based Multitasking (Multithreading)
-----------------------------------------
1)Threads share the same address space.

2)A thread is lightweight.

3)Cost of communication between the thread is low.

Note: At least one process is required for each thread.

Threads are independent. If there occurs exception in one thread, it doesn't affect other threads. It uses a shared memory area.

Java Thread class
-----------------
1)Java provides Thread class to achieve thread programming. 

2)Thread class provides constructors and methods to create and perform operations on a thread. 

3)Thread class extends Object class and implements Runnable interface.

Java Thread Methods
-------------------

1) start(): It is used to start the execution of the thread.

2) run():   It is used to do an action for a thread.

3) sleep():  It sleeps a thread for the specified amount of time.

4) currentThread(): It returns a reference to the currently executing thread object.

5) join(): It waits for a thread to die.

6) getPriority(): It returns the priority of the thread.

7) setPriority(): It changes the priority of the thread.

8) getName(): It returns the name of the thread.

9) setName(): It changes the name of the thread.

10) getId(): It returns the id of the thread.

11) isAlive(): It tests if the thread is alive

12) yield(): It causes the currently executing thread object to pause and allow other threads to execute temporarily.

13) suspend(): It is used to suspend the thread.

14) resume(): It is used to resume the suspended thread.

15) stop(): It is used to stop the thread.

16) destroy(): It is used to destroy the thread group and all of its subgroups. 

These are few methods in Java Threads.

Life Cycle of Threads
---------------------

1)New

2)Active

3)Blocked / Waiting

4)Timed Waiting

5)Terminated

New:
---
Whenever a new thread is created, it is always in the new state. For a thread in the new state, the code has not been run yet and thus has not begun its execution.

Active:
------
When a thread invokes the start() method, it moves from the new state to the active state. The active state contains two states within it: one is runnable, and the other is running.

Runnable:
--------
A thread, that is ready to run is then moved to the runnable state. In the runnable state, the thread may be running or may be ready to run at any given instant of time. It is the duty of the thread scheduler to provide the thread time to run, i.e., moving the thread the running state.

Running:
--------
When the thread gets the CPU, it moves from the runnable to the running state. Generally, the most common change in the state of a thread is from runnable to running and again back to runnable.

Blocked/waiting:
----------------

Whenever a thread is inactive for a span of time (not permanently) then, either the thread is in the blocked state or is in the waiting state.

Timed Waiting:
-------------

Timed Waiting: Sometimes, waiting for leads to starvation. For example, a thread (its name is A) has entered the critical section of a code and is not willing to leave that critical section. In such a scenario, another thread (its name is B) has to wait forever, which leads to starvation. To avoid such scenario, a timed waiting state is given to thread B. Thus, thread lies in the waiting state for a specific span of time, and not forever. A real example of timed waiting is when we invoke the sleep() method on a specific thread. The sleep() method puts the thread in the timed wait state.

Terminated:
-----------
A thread reaches the termination state because of the following reasons:

When a thread has finished its job, then it exists or terminates normally.
Abnormal termination: It occurs when some unusual events such as an unhandled exception or segmentation fault.
A terminated thread means the thread is no more in the system. In other words, the thread is dead, and there is no way one can respawn (active after kill) the dead thread.

